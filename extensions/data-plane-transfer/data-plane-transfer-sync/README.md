# Synchronous data plane transfer extension

## Overview

The `data-plane-transfer-sync` extension provides resources in order to perform synchronous data transfer using the Data
Plane, which exposes public API enabling to actively query data from the provider through the consumer Data Plane.
Access to these public Data Plane API is secured through a bearer token authorization, whose generation is ensured by
the current extension. In order to keep the Data Plane stateless, it has been chosen to embed the data source (i.e. data
address) as claim into the security token. This enables the Data Plane to retrieve the data source from which it should
retrieve the data directly from the bearer token provided in input, without having to persist any information about the
data source itself. In order to keep the provider data source secured, the present extension takes care of encrypting
the data address encoded in the claims, making it unreadable for the consumer. Bearer token also contains the contract
id coming from the `DataRequest`. This contract id is used when a data request is received by the Data Plane in order to
validate that the contract agreed between the provider and the consumer still allows the access to the requested data.

## Provider part

It basically introduces a `Provisioner` and a `DataFlowController`for supporting synchronous data transfers through the
data plane.

The `Provider` is in charge of creating an `EndpointDataReference` (EDR) which is composed of:

- the url to the public API of the provider Data Plane that should be targeted in order to collect the data,
- an authorization token (see _Overview_ section), signed with Control Plane private key.

As mentioned in the previous section, the generated token contains as claims the contract id and the actual data
address (REST API, database...) formatted as an encrypted string.

Once generated this EDR is sent back to the consumer by the `DataFlowController` through
the `RemoteMessageDispatcherRegistry`.

In the `data-protocols:ids` module an IDS `Sender` is registered (see
class `MultipartEndpointDataReferenceRequestSender`) that sends the EDR as an IDS `ParticipantUpdateNotification`
message. This message is then received by the `EndpointDataReferenceHandler` which:

- first apply the provided `EndpointDataReferenceTransformer` on the received EDR and generates a new EDR,
- then dispatch the resulting EDR by delegating to all `EndpointDataReferenceReceiver` registered in the registry.

## Consumer part

Here we register an implementation of a `EndpointDataReferenceTransformer` that builds a new EDR based on the one
received by the `EndpointDataReferenceHandler`, which is composed of:

- an url to the public API of the consumer Data Plane, i.e. consumer Data Plane is now used as a proxy to query the
  data.
- an authorization token containing as claim the EDR generated by the provider `Provisioner`, and signed with the
  Control Plane private key.

Data query process is finally as follows:

- consumer applications uses the url and token generated by its Control Plane (see previous section) as input when
  hitting its Data Plane public API.
- consumer Data Plane decodes the data address from the token which is here an EDR (url+token) whose url points on the
  provider Data Plane public API.
- using previous address, consumer Data Plane calls the provider Data Plane public API with the previous EDR token,
- provider Data Plane decodes the actual data address (REST API, database...) from the token and hits the data source in
  order to collect the data,
- data are finally cascaded to the initial caller (i.e. consumer applications) in the call responses.

## API

It registers an endpoint used by the Data Plane to validate the signed token (see sections above) received in the public
API request. This validation consists in:

- asserting the provided token was signed by the current entity, which is done by verifying the token against the
  Control Plane public key,
- checking that the token is still valid and that the Contract still allows access to the data.

If both conditions are satisfied then the token claims are returned in response to the Data Plane. These claims contain
the data address which is then used by the Data Plane to query the data.

### TODO

- Encrypt data address in the claim token: token being provided to the consumer, the latter should not be able to see
  the actual data address on provider side,
- Implement the concept of `DataPlaneResolver`, as there could be multiple Data Plane, and Control Plane should be able
  to decide to which Data Plane instance a given data transfer should be delegated. This can be decided based on the
  data transfer type (finite, streaming...) or in order to balance the load across the Data Plane instances.